# ============================================================================
# Kubernetes Secrets Configuration
# RUL Prediction System - Sensitive Data (Template)
# ============================================================================
# NOTE: This is a template. DO NOT commit actual secrets to version control.
# Create secrets using kubectl or sealed-secrets in production.
# ============================================================================

---
# Example: Create secrets using kubectl
# kubectl create secret generic rul-secrets \
#   --from-literal=database-url='postgresql://user:pass@host:5432/db' \
#   --from-literal=redis-url='redis://redis:6379/0' \
#   --from-literal=secret-key='your-secret-key' \
#   --namespace=rul-prediction

---
apiVersion: v1
kind: Secret
metadata:
  name: rul-secrets
  namespace: rul-prediction
type: Opaque
data:
  # Base64 encoded values (example - replace with actual values)
  # echo -n 'value' | base64
  database-url: cG9zdGdyZXNxbDovL3Bvc3RncmVzOnBvc3RncmVzQHBvc3RncmVzOjU0MzIvcnVsX3ByZWRpY3Rpb24=
  redis-url: cmVkaXM6Ly9yZWRpczozNjM3OS8w
  secret-key: eW91ci1zZWNyZXQta2V5LWNoYW5nZS1pbi1wcm9kdWN0aW9u
  api-key: eW91ci1hcGkta2V5
  airflow-db-url: cG9zdGdyZXNxbDovL2FpcmZsb3c6YWlyZmxvd0Bwb3N0Z3Jlczo1NDMyL2FpcmZsb3c=
  celery-broker-url: cmVkaXM6Ly9yZWRpczozNjM3OS8w
  grafana-admin-password: YWRtaW4=

---
# PostgreSQL credentials
apiVersion: v1
kind: Secret
metadata:
  name: postgres-secret
  namespace: rul-prediction
type: Opaque
data:
  # Base64 encoded
  postgres-user: cG9zdGdyZXM=
  postgres-password: cG9zdGdyZXM=
  postgres-db: cnVsX3ByZWRpY3Rpb24=

---
# Airflow Fernet key
apiVersion: v1
kind: Secret
metadata:
  name: airflow-secret
  namespace: rul-prediction
type: Opaque
data:
  # Generate: python -c "from cryptography.fernet import Fernet; print(Fernet.generate_key().decode())"
  fernet-key: WmREZmNURjdfNjBHcnJZMTY3enNpUGQ2N3BFdnMwYUdPdjJvYXNPTTFQZz0=
  webserver-secret-key: d2Vic2VydmVyLXNlY3JldC1rZXk=

---
# Monitoring authentication
apiVersion: v1
kind: Secret
metadata:
  name: monitoring-auth
  namespace: rul-prediction
type: Opaque
data:
  # htpasswd format (user:password hash)
  # Generate: htpasswd -nb admin password | base64
  auth: YWRtaW46JGFwcjEkSDY1dnBGTW0kbDNuVTdndDFkZlp6RzI0Ti5ZTW1qLwo=

---
# TLS certificates (if not using cert-manager)
apiVersion: v1
kind: Secret
metadata:
  name: rul-prediction-tls
  namespace: rul-prediction
type: kubernetes.io/tls
data:
  # Base64 encoded certificate and key
  tls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0t...
  tls.key: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0t...

---
# AWS credentials (for S3 model storage)
apiVersion: v1
kind: Secret
metadata:
  name: aws-credentials
  namespace: rul-prediction
type: Opaque
data:
  aws-access-key-id: QUtJQVhYWFhYWFhYWFhYWFhYWFhY
  aws-secret-access-key: eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eA==
  aws-region: dXMtZWFzdC0x

---
# Docker registry credentials
apiVersion: v1
kind: Secret
metadata:
  name: docker-registry-secret
  namespace: rul-prediction
type: kubernetes.io/dockerconfigjson
data:
  .dockerconfigjson: eyJhdXRocyI6eyJ5b3VyLXJlZ2lzdHJ5LmF6dXJlY3IuaW8iOnsidXNlcm5hbWUiOiJ1c2VybmFtZSIsInBhc3N3b3JkIjoicGFzc3dvcmQiLCJhdXRoIjoiZFhObGNtNWhiV1U2Y0dGemMzZHZjbVE9In19fQ==

---
# Email credentials (for alerts)
apiVersion: v1
kind: Secret
metadata:
  name: email-credentials
  namespace: rul-prediction
type: Opaque
data:
  smtp-host: c210cC5nbWFpbC5jb20=
  smtp-port: NTg3
  smtp-user: eW91ci1lbWFpbEBleGFtcGxlLmNvbQ==
  smtp-password: eW91ci1lbWFpbC1wYXNzd29yZA==

# ============================================================================
# Production Secret Management Best Practices
# ============================================================================
#
# 1. Use External Secret Managers:
#    - AWS Secrets Manager
#    - Azure Key Vault
#    - Google Secret Manager
#    - HashiCorp Vault
#
# 2. Use Sealed Secrets:
#    - Bitnami Sealed Secrets
#    - Encrypt secrets before committing to Git
#
# 3. Use Secret Rotation:
#    - Implement automatic secret rotation
#    - Update secrets without downtime
#
# 4. Access Control:
#    - Use RBAC to limit secret access
#    - Audit secret access
#
# 5. Encryption:
#    - Enable encryption at rest for etcd
#    - Use TLS for all communications
#
# Example using kubectl to create secrets:
#
# kubectl create secret generic rul-secrets \
#   --from-literal=database-url='postgresql://user:pass@host:5432/db' \
#   --from-literal=redis-url='redis://redis:6379/0' \
#   --from-literal=secret-key='$(openssl rand -base64 32)' \
#   --from-literal=api-key='$(openssl rand -base64 32)' \
#   --namespace=rul-prediction
#
# Example using sealed-secrets:
#
# kubectl create secret generic rul-secrets \
#   --from-literal=database-url='postgresql://user:pass@host:5432/db' \
#   --dry-run=client -o yaml | \
#   kubeseal -o yaml > sealed-secret.yaml
#
# ============================================================================
